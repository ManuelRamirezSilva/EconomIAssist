ğŸ“˜ DocumentaciÃ³n General del Proyecto â€“ Agente Conversacional Modular (MCP)
ğŸ§  Nombre del Proyecto
Agente Conversacional Modular con arquitectura distribuida basada en MCP (Modular Capability Protocol)

ğŸ§± 1. DescripciÃ³n General del Proyecto
Este proyecto consiste en el desarrollo de un agente conversacional inteligente y modular, construido bajo el paradigma MCP (Modular Capability Protocol) impulsado por Anthropic. El agente serÃ¡ capaz de entender intenciones de los usuarios, enrutar las peticiones hacia mÃ³dulos especializados (servers MCP), ejecutar tareas y responder de manera natural, incorporando tambiÃ©n recuperaciÃ³n de informaciÃ³n mediante un mÃ³dulo RAG.

La arquitectura se basa en una comunicaciÃ³n distribuida tipo JSON-RPC entre el cliente MCP (agente conversacional) y distintos servidores MCP, que exponen herramientas (funcionalidades) como APIs conversacionales.

ğŸ“ 2. Arquitectura del Sistema
Componentes Principales:
Usuario: InteractÃºa por texto o audio.

MCP Client (Agente Conversacional):

Procesamiento de Intenciones: Detecta quÃ© quiere hacer el usuario.

Routing Engine: Mapea intenciÃ³n a servidor/tool especÃ­fico.

Discovery: Descubre quÃ© herramientas estÃ¡n disponibles (mediante el directorio MCP).

InteracciÃ³n JSON-RPC: Se comunica con los servidores a travÃ©s de JSON-RPC.

Manejo de memoria semÃ¡ntica (contexto + cachÃ©).

MCP Servers:

Servidor DB: db.query, db.insert, etc.

Servidor Sheets: Manejo de datos en Airtable u hojas de cÃ¡lculo.

Servidor Tools: Servicios como calendario, clima, finanzas, etc.

Servidor RAG: RecuperaciÃ³n de informaciÃ³n y expansiÃ³n de contexto mediante embeddings + bÃºsqueda semÃ¡ntica.

Directorio MCP: Permite al cliente descubrir quÃ© capacidades estÃ¡n disponibles y cÃ³mo invocarlas.

Logger estructurado: Captura inputs, herramientas invocadas y resultados.

UI / Dashboard: VisualizaciÃ³n de logs e interacciÃ³n para debugging o demos.

ğŸ§ª 3. MÃ©tricas de EvaluaciÃ³n del Agente
FCR (First Contact Resolution): Â¿El agente resolviÃ³ la consulta en la primera interacciÃ³n?

PrecisiÃ³n por intenciÃ³n: Â¿Identifica correctamente quÃ© quiere hacer el usuario?

Latencia promedio por turno: Â¿QuÃ© tan rÃ¡pido responde el sistema?

EvaluaciÃ³n semÃ¡ntica automÃ¡tica: ComparaciÃ³n de embedding de la respuesta con la respuesta esperada.

EvaluaciÃ³n humana (formulario): Escala Likert o ranking de calidad.

Tasa de Ã©xito de ejecuciÃ³n (herramientas): Â¿Falla la llamada JSON-RPC?

Cobertura de herramientas: Â¿QuÃ© proporciÃ³n de intents se pueden resolver con las herramientas disponibles?

ğŸš§ 4. Backlog del MVP y OrganizaciÃ³n Ãgil
El equipo estÃ¡ compuesto por 4 integrantes. Se utilizarÃ¡ SCRUM con 5 sprints semanales. A continuaciÃ³n, se detalla el backlog por sprint (con puntajes y descripciones breves):



ğŸ—“ Sprint 1 â€“ Fundamentos y Setup
ğŸ“¦ Inicializar entorno y repositorio compartido [Infra] â€“ 3
Setear entorno de desarrollo colaborativo con control de versiones.

âš™ï¸ Procesamiento de lenguaje natural (extracciÃ³n de intenciones) [MCP Client] â€“ 8
Pipeline para detectar quÃ© desea hacer el usuario (NLU).

ğŸ”Œ Integrar SDK de cliente MCP (Anthropic JSON-RPC) [MCP Client] â€“ 5
Conectar con protocolo JSON-RPC, configurar autenticaciÃ³n, sesiones.

ğŸ” Discovery de capacidades (Capability Discovery) [MCP Client] â€“ 5
Consultar el directorio MCP para saber quÃ© herramientas estÃ¡n disponibles.

ğŸ“ Configurar Service Discovery (directorio MCP) [MCP Client] â€“ 3
Exponer metadata de servidores MCP para permitir descubrimiento.

ğŸ§­ Documentar arquitectura general (primer borrador) [Docs] â€“ 3
Diagrama, descripciÃ³n tÃ©cnica y visiÃ³n general.

ğŸ—“ Sprint 2 â€“ Primer flujo funcional + RAG
ğŸš¦ Routing Engine (intenciÃ³n â†’ servicio) [MCP Client] â€“ 5
Mapa intenciÃ³n â†’ tool, con fallback y validaciones.

ğŸ§  MÃ³dulo RAG Server (IA + recuperaciÃ³n de info) [MCP Server] â€“ 8
Embeddings + bÃºsqueda semÃ¡ntica + expansiÃ³n de contexto.

ğŸ“„ Servidor Sheets/Airtable [MCP Server] â€“ 5
Servidor para consultar datos estructurados (ej: horarios, inventarios).

ğŸ’¾ MÃ³dulo de memoria del modelo (session + cache) [Infra] â€“ 5
Almacenar inputs anteriores + entidades claves.

ğŸ” Validar flujo end-to-end [QA] â€“ 3
Input â†’ intenciÃ³n â†’ servicio â†’ respuesta.

ğŸ“‰ Logs estructurados (servicio + respuestas) [Observability] â€“ 3
Registrar todas las interacciones clave del sistema.

ğŸ—“ Sprint 3 â€“ Herramientas auxiliares + MÃ©tricas
ğŸ”§ Tools Server (servicios auxiliares) [MCP Server] â€“ 5
Ej: calendario, clima, dÃ³lar, etc.

ğŸ“ˆ Medir latencia y precisiÃ³n semÃ¡ntica [EvaluaciÃ³n] â€“ 3
Monitoreo de rendimiento tÃ©cnico y coherencia.

ğŸ§  Memoria de conversaciÃ³n con contexto semÃ¡ntico [MCP Client] â€“ 5
FusiÃ³n de memoria + contexto expandido por RAG.

ğŸ“Š Instrumentar logging para mediciÃ³n de rendimiento [Observability] â€“ 3
Tiempo por turno, errores por herramienta.

ğŸ“‹ Formulario de evaluaciÃ³n humana [EvaluaciÃ³n] â€“ 3
Instrumento para evaluar la calidad de las respuestas.

ğŸ—“ Sprint 4 â€“ Refactor + VisualizaciÃ³n + Poster
ğŸ§¹ Refactor + modularizaciÃ³n del cÃ³digo [DevOps] â€“ 5
ReorganizaciÃ³n por capas y mÃ³dulos.

ğŸŒ UI de visualizaciÃ³n de logs (web o Streamlit) [VisualizaciÃ³n] â€“ 5
Permite ver inputs, outputs y herramientas invocadas.

ğŸ§¾ Contenido tÃ©cnico para pÃ³ster [Docs] â€“ 3
Resumen tÃ©cnico para presentaciÃ³n acadÃ©mica.

ğŸ¯ Medir FCR y precisiÃ³n por intenciÃ³n [EvaluaciÃ³n] â€“ 3
Benchmark sobre efectividad real.

ğŸ¤– Soporte para intents mÃºltiples por consulta [MCP Client] â€“ 5
Separar y ejecutar mÃºltiples intenciones en un mismo turno.

ğŸ¥ Casos de uso para demo [PresentaciÃ³n] â€“ 3
Preparar ejemplos que muestren funcionalidades.

ğŸ—“ Sprint 5 â€“ QA Final + PresentaciÃ³n
ğŸ§ª Test prompts largos / edge cases [QA] â€“ 3
Inputs ambiguos, extensos, inesperados.

ğŸ”„ Validar errores de servidor [QA] â€“ 3
Simular caÃ­das, timeouts, y analizar cÃ³mo responde el cliente.

ğŸ“š ConversaciÃ³n multi-servicio [QA] â€“ 3
Ejecutar un flujo donde se usen 2+ servidores MCP.

ğŸ—£ Ensayo general con el pÃ³ster [PresentaciÃ³n] â€“ 3
Simular presentaciÃ³n completa y revisiÃ³n cruzada.

ğŸ‘¥ RevisiÃ³n cruzada del equipo [QA] â€“ 3
Code review + revisiÃ³n de material de presentaciÃ³n.

ğŸ”§ Ãšltimos ajustes finales [DevOps] â€“ 1
OptimizaciÃ³n final antes de la entrega.

ğŸ§  Consideraciones TÃ©cnicas Avanzadas
Protocolo de comunicaciÃ³n: JSON-RPC 2.0 sobre stdio o HTTP/sse.

Modelo base: Claude-3 (o compatible) con API de Anthropic.

Discovery automÃ¡tico: El cliente pregunta al directorio quÃ© herramientas estÃ¡n disponibles, cada una define su schema.

Fallback a RAG: Si ninguna herramienta puede resolver la intenciÃ³n, se consulta al servidor RAG con embeddings.

Memoria semÃ¡ntica: FusiÃ³n de contextos histÃ³ricos + recuperaciÃ³n RAG para mantener coherencia.

